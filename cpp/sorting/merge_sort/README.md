# Merge sort

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Description :</a></li>
<li><a href="#sec-2">2. Analysis :</a></li>
<li><a href="#sec-3">3. Member functions :</a>
</li>
<li><a href="#sec-4">4. <span class="todo TODO">TODO</span> :</a></li>
</ul>
</div>
</div>

# Description :<a id="sec-1" name="sec-1"></a>

Merge sort implementation which is a sorting algorithm. The merge
sort break down the main problem (sorting an array) into
subproblems. Once the problem is break down, we solve the
subproblems recursively to end up with the entire problem solved.
They are three steps :

Divide : Find middle of the array and recall the function to
do the same procedures on the two subarrays until they are equals
to one element.
Conquer : Recursively sort the subarrays generated by the divide
step 
Combine : Combine the sorted subarrays to end up with the entire
array sorted. <br />

# Analysis :<a id="sec-2" name="sec-2"></a>

Merge sort is more efficient than the insertion or selection sort
algorithm on a larger number of input (Average case O(n log n)).
But might be less efficient than the insertion sort. For example
sorting an array that is already sorted. Also, this algorithm use
memory space.
Even if the complexity of the merge sort algorithm is more efficient
that other, it doesn't mean that this algorithm will be much faster
in all cases. <br />

# Member functions :<a id="sec-3" name="sec-3"></a>

## void sort(std::vector<int> &array);<a id="sec-3-1" name="sec-3-1"></a>

Sort the given array using the merge sort algorithm.

## int number\_of\_guesses(int size);<a id="sec-3-2" name="sec-3-2"></a>

Return the maximum number of tries for the algorithm to find a value. <br />

# TODO :<a id="sec-4" name="sec-4"></a>

-   More flexibility (Templates)